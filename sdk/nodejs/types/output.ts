// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface CdnDistributionConfig {
    /**
     * The configured backend for the distribution
     */
    backend: outputs.CdnDistributionConfigBackend;
    /**
     * The configured regions where content will be hosted
     */
    regions: string[];
}

export interface CdnDistributionConfigBackend {
    /**
     * The configured origin request headers for the backend
     */
    originRequestHeaders?: {[key: string]: string};
    /**
     * The configured backend type for the distribution
     */
    originUrl: string;
    /**
     * The configured backend type. Supported values are: `http`.
     */
    type: string;
}

export interface CdnDistributionDomain {
    /**
     * List of domain errors
     */
    errors: string[];
    /**
     * The name of the domain
     */
    name: string;
    /**
     * The status of the domain
     */
    status: string;
    /**
     * The type of the domain. Each distribution has one domain of type "managed", and domains of type "custom" may be additionally created by the user
     */
    type: string;
}

export interface GetCdnDistributionConfig {
    /**
     * The configured backend for the distribution
     */
    backend: outputs.GetCdnDistributionConfigBackend;
    /**
     * The configured regions where content will be hosted
     */
    regions: string[];
}

export interface GetCdnDistributionConfigBackend {
    /**
     * The configured origin request headers for the backend
     */
    originRequestHeaders: {[key: string]: string};
    /**
     * The configured backend type for the distribution
     */
    originUrl: string;
    /**
     * The configured backend type. Supported values are: `http`.
     */
    type: string;
}

export interface GetCdnDistributionDomain {
    /**
     * List of domain errors
     */
    errors: string[];
    /**
     * The name of the domain
     */
    name: string;
    /**
     * The status of the domain
     */
    status: string;
    /**
     * The type of the domain. Each distribution has one domain of type "managed", and domains of type "custom" may be additionally created by the user
     */
    type: string;
}

export interface GetImageChecksum {
    /**
     * Algorithm for the checksum of the image data.
     */
    algorithm: string;
    /**
     * Hexdigest of the checksum of the image data.
     */
    digest: string;
}

export interface GetImageConfig {
    /**
     * Enables the BIOS bootmenu.
     */
    bootMenu: boolean;
    /**
     * Sets CDROM bus controller type.
     */
    cdromBus: string;
    /**
     * Sets Disk bus controller type.
     */
    diskBus: string;
    /**
     * Sets virtual network interface model.
     */
    nicModel: string;
    /**
     * Enables operating system specific optimizations.
     */
    operatingSystem: string;
    /**
     * Operating system distribution.
     */
    operatingSystemDistro: string;
    /**
     * Version of the operating system.
     */
    operatingSystemVersion: string;
    /**
     * Sets the device bus when the image is used as a rescue image.
     */
    rescueBus: string;
    /**
     * Sets the device when the image is used as a rescue image.
     */
    rescueDevice: string;
    /**
     * Enables Secure Boot.
     */
    secureBoot: boolean;
    /**
     * Enables UEFI boot.
     */
    uefi: boolean;
    /**
     * Sets Graphic device model.
     */
    videoModel: string;
    /**
     * Enables the use of VirtIO SCSI to provide block device access. By default instances use VirtIO Block.
     */
    virtioScsi: boolean;
}

export interface GetLoadbalancerListener {
    displayName: string;
    /**
     * Port number where we listen for traffic.
     */
    port: number;
    /**
     * Protocol is the highest network protocol we understand to load balance.
     */
    protocol: string;
    /**
     * A list of domain names to match in order to pass TLS traffic to the target pool in the current listener
     */
    serverNameIndicators?: outputs.GetLoadbalancerListenerServerNameIndicator[];
    /**
     * Reference target pool by target pool name.
     */
    targetPool: string;
}

export interface GetLoadbalancerListenerServerNameIndicator {
    /**
     * A domain name to match in order to pass TLS traffic to the target pool in the current listener
     */
    name?: string;
}

export interface GetLoadbalancerNetwork {
    /**
     * Openstack network ID.
     */
    networkId: string;
    /**
     * The role defines how the load balancer is using the network.
     */
    role: string;
}

export interface GetLoadbalancerOptions {
    /**
     * Load Balancer is accessible only from an IP address in this range.
     */
    acls: string[];
    /**
     * We offer Load Balancer metrics observability via ARGUS or external solutions.
     */
    observability: outputs.GetLoadbalancerOptionsObservability;
    /**
     * If true, Load Balancer is accessible only via a private network IP address.
     */
    privateNetworkOnly: boolean;
}

export interface GetLoadbalancerOptionsObservability {
    /**
     * Observability logs configuration.
     */
    logs: outputs.GetLoadbalancerOptionsObservabilityLogs;
    /**
     * Observability metrics configuration.
     */
    metrics: outputs.GetLoadbalancerOptionsObservabilityMetrics;
}

export interface GetLoadbalancerOptionsObservabilityLogs {
    /**
     * Credentials reference for logs.
     */
    credentialsRef: string;
    /**
     * Credentials reference for logs.
     */
    pushUrl: string;
}

export interface GetLoadbalancerOptionsObservabilityMetrics {
    /**
     * Credentials reference for metrics.
     */
    credentialsRef: string;
    /**
     * Credentials reference for metrics.
     */
    pushUrl: string;
}

export interface GetLoadbalancerTargetPool {
    activeHealthCheck: outputs.GetLoadbalancerTargetPoolActiveHealthCheck;
    /**
     * Target pool name.
     */
    name: string;
    /**
     * Here you can setup various session persistence options, so far only "`useSourceIpAddress`" is supported.
     */
    sessionPersistence?: outputs.GetLoadbalancerTargetPoolSessionPersistence;
    /**
     * Identical port number where each target listens for traffic.
     */
    targetPort: number;
    /**
     * List of all targets which will be used in the pool. Limited to 1000.
     */
    targets: outputs.GetLoadbalancerTargetPoolTarget[];
}

export interface GetLoadbalancerTargetPoolActiveHealthCheck {
    /**
     * Healthy threshold of the health checking.
     */
    healthyThreshold: number;
    /**
     * Interval duration of health checking in seconds.
     */
    interval: string;
    /**
     * Interval duration threshold of the health checking in seconds.
     */
    intervalJitter: string;
    /**
     * Active health checking timeout duration in seconds.
     */
    timeout: string;
    /**
     * Unhealthy threshold of the health checking.
     */
    unhealthyThreshold: number;
}

export interface GetLoadbalancerTargetPoolSessionPersistence {
    /**
     * If true then all connections from one source IP address are redirected to the same target. This setting changes the load balancing algorithm to Maglev.
     */
    useSourceIpAddress?: boolean;
}

export interface GetLoadbalancerTargetPoolTarget {
    /**
     * Target display name
     */
    displayName: string;
    /**
     * Target IP
     */
    ip: string;
}

export interface GetLogmeInstanceParameters {
    /**
     * Enable monitoring.
     */
    enableMonitoring: boolean;
    fluentdTcp: number;
    fluentdTls: number;
    fluentdTlsCiphers: string;
    fluentdTlsMaxVersion: string;
    fluentdTlsMinVersion: string;
    fluentdTlsVersion: string;
    fluentdUdp: number;
    /**
     * If set, monitoring with Graphite will be enabled. Expects the host and port where the Graphite metrics should be sent to (host:port).
     */
    graphite: string;
    /**
     * Combination of an integer and a timerange when an index will be considered "old" and can be deleted. Possible values for the timerange are `s`, `m`, `h` and `d`.
     */
    ismDeletionAfter: string;
    ismJitter: number;
    /**
     * Jitter of the execution time.
     */
    ismJobInterval: number;
    /**
     * The amount of memory (in MB) allocated as heap by the JVM for OpenSearch.
     */
    javaHeapspace: number;
    /**
     * The amount of memory (in MB) used by the JVM to store metadata for OpenSearch.
     */
    javaMaxmetaspace: number;
    /**
     * The maximum disk threshold in MB. If the disk usage exceeds this threshold, the instance will be stopped.
     */
    maxDiskThreshold: number;
    /**
     * The frequency in seconds at which metrics are emitted (in seconds).
     */
    metricsFrequency: number;
    /**
     * The prefix for the metrics. Could be useful when using Graphite monitoring to prefix the metrics with a certain value, like an API key.
     */
    metricsPrefix: string;
    /**
     * The ID of the STACKIT monitoring instance.
     */
    monitoringInstanceId: string;
    opensearchTlsCiphers: string[];
    opensearchTlsProtocols: string[];
    /**
     * Comma separated list of IP networks in CIDR notation which are allowed to access this instance.
     */
    sgwAcl: string;
    /**
     * List of syslog servers to send logs to.
     */
    syslogs: string[];
}

export interface GetMariadbInstanceParameters {
    /**
     * Enable monitoring.
     */
    enableMonitoring: boolean;
    graphite: string;
    /**
     * The maximum disk threshold in MB. If the disk usage exceeds this threshold, the instance will be stopped.
     */
    maxDiskThreshold: number;
    /**
     * The frequency in seconds at which metrics are emitted.
     */
    metricsFrequency: number;
    /**
     * The prefix for the metrics. Could be useful when using Graphite monitoring to prefix the metrics with a certain value, like an API key
     */
    metricsPrefix: string;
    /**
     * The ID of the STACKIT monitoring instance.
     */
    monitoringInstanceId: string;
    /**
     * Comma separated list of IP networks in CIDR notation which are allowed to access this instance.
     */
    sgwAcl: string;
    /**
     * List of syslog servers to send logs to.
     */
    syslogs: string[];
}

export interface GetMongodbflexInstanceFlavor {
    cpu: number;
    description: string;
    id: string;
    ram: number;
}

export interface GetMongodbflexInstanceOptions {
    /**
     * The number of days that daily backups will be retained.
     */
    dailySnapshotRetentionDays: number;
    /**
     * The number of months that monthly backups will be retained.
     */
    monthlySnapshotRetentionMonths: number;
    /**
     * The number of hours back in time the point-in-time recovery feature will be able to recover.
     */
    pointInTimeWindowHours: number;
    /**
     * The number of days that continuous backups (controlled via the `backupSchedule`) will be retained.
     */
    snapshotRetentionDays: number;
    /**
     * Type of the MongoDB Flex instance.
     */
    type: string;
    /**
     * The number of weeks that weekly backups will be retained.
     */
    weeklySnapshotRetentionWeeks: number;
}

export interface GetMongodbflexInstanceStorage {
    class: string;
    size: number;
}

export interface GetNetworkAreaNetworkRange {
    networkRangeId: string;
    prefix: string;
}

export interface GetObservabilityAlertgroupRule {
    /**
     * The name of the alert rule. Is the identifier and must be unique in the group.
     */
    alert: string;
    /**
     * A map of key:value. Annotations to add or overwrite for each alert
     */
    annotations: {[key: string]: string};
    /**
     * The PromQL expression to evaluate. Every evaluation cycle this is evaluated at the current time, and all resultant time series become pending/firing alerts.
     */
    expression: string;
    /**
     * Alerts are considered firing once they have been returned for this long. Alerts which have not yet fired for long enough are considered pending. Default is 0s
     */
    for: string;
    /**
     * A map of key:value. Labels to add or overwrite for each alert
     */
    labels: {[key: string]: string};
}

export interface GetObservabilityInstanceAlertConfig {
    /**
     * Global configuration for the alerts.
     */
    global: outputs.GetObservabilityInstanceAlertConfigGlobal;
    /**
     * List of alert receivers.
     */
    receivers: outputs.GetObservabilityInstanceAlertConfigReceiver[];
    /**
     * The route for the alert.
     */
    route: outputs.GetObservabilityInstanceAlertConfigRoute;
}

export interface GetObservabilityInstanceAlertConfigGlobal {
    /**
     * The API key for OpsGenie.
     */
    opsgenieApiKey: string;
    /**
     * The host to send OpsGenie API requests to. Must be a valid URL
     */
    opsgenieApiUrl: string;
    /**
     * The default value used by alertmanager if the alert does not include EndsAt. After this time passes, it can declare the alert as resolved if it has not been updated. This has no impact on alerts from Prometheus, as they always include EndsAt.
     */
    resolveTimeout: string;
    /**
     * SMTP authentication information. Must be a valid email address
     */
    smtpAuthIdentity: string;
    /**
     * SMTP Auth using LOGIN and PLAIN.
     */
    smtpAuthPassword: string;
    /**
     * SMTP Auth using CRAM-MD5, LOGIN and PLAIN. If empty, Alertmanager doesn't authenticate to the SMTP server.
     */
    smtpAuthUsername: string;
    /**
     * The default SMTP From header field. Must be a valid email address
     */
    smtpFrom: string;
    /**
     * The default SMTP smarthost used for sending emails, including port number. Port number usually is 25, or 587 for SMTP over TLS (sometimes referred to as STARTTLS).
     */
    smtpSmartHost: string;
}

export interface GetObservabilityInstanceAlertConfigReceiver {
    /**
     * List of email configurations.
     */
    emailConfigs: outputs.GetObservabilityInstanceAlertConfigReceiverEmailConfig[];
    /**
     * Name of the receiver.
     */
    name: string;
    /**
     * List of OpsGenie configurations.
     */
    opsgenieConfigs: outputs.GetObservabilityInstanceAlertConfigReceiverOpsgenieConfig[];
    /**
     * List of Webhooks configurations.
     */
    webhooksConfigs: outputs.GetObservabilityInstanceAlertConfigReceiverWebhooksConfig[];
}

export interface GetObservabilityInstanceAlertConfigReceiverEmailConfig {
    /**
     * SMTP authentication information. Must be a valid email address
     */
    authIdentity: string;
    /**
     * SMTP authentication password.
     */
    authPassword: string;
    /**
     * SMTP authentication username.
     */
    authUsername: string;
    /**
     * The sender email address. Must be a valid email address
     */
    from: string;
    /**
     * The SMTP host through which emails are sent.
     */
    smartHost: string;
    /**
     * The email address to send notifications to. Must be a valid email address
     */
    to: string;
}

export interface GetObservabilityInstanceAlertConfigReceiverOpsgenieConfig {
    /**
     * The API key for OpsGenie.
     */
    apiKey: string;
    /**
     * The host to send OpsGenie API requests to. Must be a valid URL
     */
    apiUrl: string;
    /**
     * Comma separated list of tags attached to the notifications.
     */
    tags: string;
}

export interface GetObservabilityInstanceAlertConfigReceiverWebhooksConfig {
    /**
     * Microsoft Teams webhooks require special handling, set this to true if the webhook is for Microsoft Teams.
     */
    msTeams: boolean;
    /**
     * The endpoint to send HTTP POST requests to. Must be a valid URL
     */
    url: string;
}

export interface GetObservabilityInstanceAlertConfigRoute {
    /**
     * The labels by which incoming alerts are grouped together. For example, multiple alerts coming in for cluster=A and alertname=LatencyHigh would be batched into a single group. To aggregate by all possible labels use the special value '...' as the sole label name, for example: group_by: ['...']. This effectively disables aggregation entirely, passing through all alerts as-is. This is unlikely to be what you want, unless you have a very low alert volume or your upstream notification system performs its own grouping.
     */
    groupBies: string[];
    /**
     * How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.)
     */
    groupInterval: string;
    /**
     * How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group. (Usually ~0s to few minutes.) .
     */
    groupWait: string;
    /**
     * A set of equality matchers an alert has to fulfill to match the node.
     */
    match: {[key: string]: string};
    /**
     * A set of regex-matchers an alert has to fulfill to match the node.
     */
    matchRegex: {[key: string]: string};
    /**
     * The name of the receiver to route the alerts to.
     */
    receiver: string;
    /**
     * How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more).
     */
    repeatInterval: string;
    /**
     * List of child routes.
     */
    routes: outputs.GetObservabilityInstanceAlertConfigRouteRoute[];
}

export interface GetObservabilityInstanceAlertConfigRouteRoute {
    /**
     * The labels by which incoming alerts are grouped together. For example, multiple alerts coming in for cluster=A and alertname=LatencyHigh would be batched into a single group. To aggregate by all possible labels use the special value '...' as the sole label name, for example: group_by: ['...']. This effectively disables aggregation entirely, passing through all alerts as-is. This is unlikely to be what you want, unless you have a very low alert volume or your upstream notification system performs its own grouping.
     */
    groupBies: string[];
    /**
     * How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.)
     */
    groupInterval: string;
    /**
     * How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group. (Usually ~0s to few minutes.)
     */
    groupWait: string;
    /**
     * A set of equality matchers an alert has to fulfill to match the node.
     */
    match: {[key: string]: string};
    /**
     * A set of regex-matchers an alert has to fulfill to match the node.
     */
    matchRegex: {[key: string]: string};
    /**
     * The name of the receiver to route the alerts to.
     */
    receiver: string;
    /**
     * How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more).
     */
    repeatInterval: string;
}

export interface GetObservabilityLogalertgroupRule {
    /**
     * The name of the alert rule. Is the identifier and must be unique in the group.
     */
    alert: string;
    /**
     * A map of key:value. Annotations to add or overwrite for each alert
     */
    annotations: {[key: string]: string};
    /**
     * The LogQL expression to evaluate. Every evaluation cycle this is evaluated at the current time, and all resultant time series become pending/firing alerts.
     */
    expression: string;
    /**
     * Alerts are considered firing once they have been returned for this long. Alerts which have not yet fired for long enough are considered pending. Default is 0s
     */
    for: string;
    /**
     * A map of key:value. Labels to add or overwrite for each alert
     */
    labels: {[key: string]: string};
}

export interface GetObservabilityScrapeconfigBasicAuth {
    /**
     * Specifies basic auth password.
     */
    password: string;
    /**
     * Specifies basic auth username.
     */
    username: string;
}

export interface GetObservabilityScrapeconfigSaml2 {
    /**
     * Specifies if URL parameters are enabled
     */
    enableUrlParameters: boolean;
}

export interface GetObservabilityScrapeconfigTarget {
    /**
     * Specifies labels.
     */
    labels: {[key: string]: string};
    /**
     * Specifies target URLs.
     */
    urls: string[];
}

export interface GetOpensearchInstanceParameters {
    /**
     * Enable monitoring.
     */
    enableMonitoring: boolean;
    /**
     * If set, monitoring with Graphite will be enabled. Expects the host and port where the Graphite metrics should be sent to (host:port).
     */
    graphite: string;
    /**
     * The garbage collector to use for OpenSearch.
     */
    javaGarbageCollector: string;
    /**
     * The amount of memory (in MB) allocated as heap by the JVM for OpenSearch.
     */
    javaHeapspace: number;
    /**
     * The amount of memory (in MB) used by the JVM to store metadata for OpenSearch.
     */
    javaMaxmetaspace: number;
    /**
     * The maximum disk threshold in MB. If the disk usage exceeds this threshold, the instance will be stopped.
     */
    maxDiskThreshold: number;
    /**
     * The frequency in seconds at which metrics are emitted (in seconds).
     */
    metricsFrequency: number;
    /**
     * The prefix for the metrics. Could be useful when using Graphite monitoring to prefix the metrics with a certain value, like an API key.
     */
    metricsPrefix: string;
    /**
     * The ID of the STACKIT monitoring instance.
     */
    monitoringInstanceId: string;
    /**
     * List of plugins to install. Must be a supported plugin name. The plugins `repository-s3` and `repository-azure` are enabled by default and cannot be disabled.
     */
    plugins: string[];
    /**
     * Comma separated list of IP networks in CIDR notation which are allowed to access this instance.
     */
    sgwAcl: string;
    /**
     * List of syslog servers to send logs to.
     */
    syslogs: string[];
    /**
     * List of TLS ciphers to use.
     */
    tlsCiphers: string[];
    /**
     * The TLS protocol to use.
     */
    tlsProtocols: string;
}

export interface GetPostgresflexInstanceFlavor {
    cpu: number;
    description: string;
    id: string;
    ram: number;
}

export interface GetPostgresflexInstanceStorage {
    class: string;
    size: number;
}

export interface GetPublicIpRangesPublicIpRange {
    /**
     * Classless Inter-Domain Routing (CIDR)
     */
    cidr: string;
}

export interface GetRabbitmqInstanceParameters {
    /**
     * The timeout in milliseconds for the consumer.
     */
    consumerTimeout: number;
    /**
     * Enable monitoring.
     */
    enableMonitoring: boolean;
    /**
     * Graphite server URL (host and port). If set, monitoring with Graphite will be enabled.
     */
    graphite: string;
    /**
     * The maximum disk threshold in MB. If the disk usage exceeds this threshold, the instance will be stopped.
     */
    maxDiskThreshold: number;
    /**
     * The frequency in seconds at which metrics are emitted.
     */
    metricsFrequency: number;
    /**
     * The prefix for the metrics. Could be useful when using Graphite monitoring to prefix the metrics with a certain value, like an API key
     */
    metricsPrefix: string;
    /**
     * The ID of the STACKIT monitoring instance.
     */
    monitoringInstanceId: string;
    /**
     * List of plugins to install. Must be a supported plugin name.
     */
    plugins: string[];
    /**
     * List of roles to assign to the instance.
     */
    roles: string[];
    /**
     * Comma separated list of IP networks in CIDR notation which are allowed to access this instance.
     */
    sgwAcl: string;
    /**
     * List of syslog servers to send logs to.
     */
    syslogs: string[];
    /**
     * List of TLS ciphers to use.
     */
    tlsCiphers: string[];
    /**
     * TLS protocol to use.
     */
    tlsProtocols: string;
}

export interface GetRedisInstanceParameters {
    /**
     * The number of milliseconds after which the instance is considered down.
     */
    downAfterMilliseconds: number;
    /**
     * Enable monitoring.
     */
    enableMonitoring: boolean;
    /**
     * The failover timeout in milliseconds.
     */
    failoverTimeout: number;
    /**
     * Graphite server URL (host and port). If set, monitoring with Graphite will be enabled.
     */
    graphite: string;
    /**
     * The lazy eviction enablement (yes or no).
     */
    lazyfreeLazyEviction: string;
    /**
     * The lazy expire enablement (yes or no).
     */
    lazyfreeLazyExpire: string;
    /**
     * The Lua time limit.
     */
    luaTimeLimit: number;
    /**
     * The maximum disk threshold in MB. If the disk usage exceeds this threshold, the instance will be stopped.
     */
    maxDiskThreshold: number;
    /**
     * The maximum number of clients.
     */
    maxclients: number;
    /**
     * The policy to handle the maximum memory (volatile-lru, noeviction, etc).
     */
    maxmemoryPolicy: string;
    /**
     * The maximum memory samples.
     */
    maxmemorySamples: number;
    /**
     * The frequency in seconds at which metrics are emitted.
     */
    metricsFrequency: number;
    /**
     * The prefix for the metrics. Could be useful when using Graphite monitoring to prefix the metrics with a certain value, like an API key
     */
    metricsPrefix: string;
    /**
     * The minimum replicas maximum lag.
     */
    minReplicasMaxLag: number;
    /**
     * The ID of the STACKIT monitoring instance.
     */
    monitoringInstanceId: string;
    /**
     * The notify keyspace events.
     */
    notifyKeyspaceEvents: string;
    /**
     * Comma separated list of IP networks in CIDR notation which are allowed to access this instance.
     */
    sgwAcl: string;
    /**
     * The snapshot configuration.
     */
    snapshot: string;
    /**
     * List of syslog servers to send logs to.
     */
    syslogs: string[];
    /**
     * List of TLS ciphers to use.
     */
    tlsCiphers: string[];
    /**
     * TLS cipher suites to use.
     */
    tlsCiphersuites: string;
    /**
     * TLS protocol to use.
     */
    tlsProtocols: string;
}

export interface GetSecurityGroupRuleIcmpParameters {
    /**
     * ICMP code. Can be set if the protocol is ICMP.
     */
    code: number;
    /**
     * ICMP type. Can be set if the protocol is ICMP.
     */
    type: number;
}

export interface GetSecurityGroupRulePortRange {
    /**
     * The maximum port number. Should be greater or equal to the minimum.
     */
    max: number;
    /**
     * The minimum port number. Should be less or equal to the minimum.
     */
    min: number;
}

export interface GetSecurityGroupRuleProtocol {
    /**
     * The protocol name which the rule should match.
     */
    name: string;
    /**
     * The protocol number which the rule should match.
     */
    number: number;
}

export interface GetServerBackupScheduleBackupProperties {
    name: string;
    retentionPeriod: number;
    volumeIds: string[];
}

export interface GetServerBackupSchedulesItem {
    /**
     * Backup schedule details for the backups.
     */
    backupProperties: outputs.GetServerBackupSchedulesItemBackupProperties;
    backupScheduleId: number;
    /**
     * Is the backup schedule enabled or disabled.
     */
    enabled: boolean;
    /**
     * The backup schedule name.
     */
    name: string;
    /**
     * Backup schedule described in `rrule` (recurrence rule) format.
     */
    rrule: string;
}

export interface GetServerBackupSchedulesItemBackupProperties {
    name: string;
    retentionPeriod: number;
    volumeIds: string[];
}

export interface GetServerBootVolume {
    /**
     * Delete the volume during the termination of the server.
     */
    deleteOnTermination: boolean;
    /**
     * The ID of the boot volume
     */
    id: string;
}

export interface GetServerUpdateSchedulesItem {
    /**
     * Is the update schedule enabled or disabled.
     */
    enabled: boolean;
    /**
     * Maintenance window [1..24].
     */
    maintenanceWindow: number;
    /**
     * The update schedule name.
     */
    name: string;
    /**
     * Update schedule described in `rrule` (recurrence rule) format.
     */
    rrule: string;
    updateScheduleId: number;
}

export interface GetSkeClusterExtensions {
    /**
     * Cluster access control configuration
     */
    acl: outputs.GetSkeClusterExtensionsAcl;
    /**
     * A single argus block as defined below
     */
    argus: outputs.GetSkeClusterExtensionsArgus;
    /**
     * DNS extension configuration
     */
    dns: outputs.GetSkeClusterExtensionsDns;
}

export interface GetSkeClusterExtensionsAcl {
    /**
     * Specify a list of CIDRs to whitelist
     */
    allowedCidrs: string[];
    /**
     * Is ACL enabled?
     */
    enabled: boolean;
}

export interface GetSkeClusterExtensionsArgus {
    /**
     * Instance ID of argus
     */
    argusInstanceId: string;
    /**
     * Flag to enable/disable argus extensions.
     */
    enabled: boolean;
}

export interface GetSkeClusterExtensionsDns {
    /**
     * Flag to enable/disable DNS extensions
     */
    enabled: boolean;
    /**
     * Specify a list of domain filters for externalDNS (e.g., `foo.runs.onstackit.cloud`)
     */
    zones: string[];
}

export interface GetSkeClusterHibernation {
    /**
     * End time of hibernation, in crontab syntax.
     */
    end: string;
    /**
     * Start time of cluster hibernation in crontab syntax.
     */
    start: string;
    /**
     * Timezone name corresponding to a file in the IANA Time Zone database.
     */
    timezone: string;
}

export interface GetSkeClusterMaintenance {
    /**
     * Flag to enable/disable auto-updates of the Kubernetes version.
     */
    enableKubernetesVersionUpdates: boolean;
    /**
     * Flag to enable/disable auto-updates of the OS image version.
     */
    enableMachineImageVersionUpdates: boolean;
    /**
     * Date time for maintenance window end.
     */
    end: string;
    /**
     * Date time for maintenance window start.
     */
    start: string;
}

export interface GetSkeClusterNetwork {
    /**
     * ID of the STACKIT Network Area (SNA) network into which the cluster will be deployed.
     */
    id: string;
}

export interface GetSkeClusterNodePool {
    /**
     * Allow system components to run on this node pool.
     */
    allowSystemComponents: boolean;
    /**
     * Specify a list of availability zones.
     */
    availabilityZones: string[];
    /**
     * Specifies the container runtime.
     */
    cri: string;
    /**
     * Labels to add to each node.
     */
    labels: {[key: string]: string};
    /**
     * The machine type.
     */
    machineType: string;
    /**
     * The maximum number of nodes upgraded simultaneously.
     */
    maxSurge: number;
    /**
     * The maximum number of nodes unavailable during upgraded.
     */
    maxUnavailable: number;
    /**
     * Maximum number of nodes in the pool.
     */
    maximum: number;
    /**
     * Minimum number of nodes in the pool.
     */
    minimum: number;
    /**
     * Specifies the name of the node pool.
     */
    name: string;
    /**
     * The name of the OS image.
     */
    osName: string;
    /**
     * The OS image version.
     */
    osVersion: string;
    /**
     * The minimum OS image version, this field is always nil. SKE automatically updates the cluster Kubernetes version if you have set `maintenance.enable_kubernetes_version_updates` to true or if there is a mandatory update, as described in [Updates for Kubernetes versions and Operating System versions in SKE](https://docs.stackit.cloud/stackit/en/version-updates-in-ske-10125631.html). To get the current OS image version being used for the node pool, use the read-only `osVersionUsed` field.
     */
    osVersionMin: string;
    /**
     * Full OS image version used. For example, if 3815.2 was set in `osVersionMin`, this value may result to 3815.2.2. SKE automatically updates the cluster Kubernetes version if you have set `maintenance.enable_kubernetes_version_updates` to true or if there is a mandatory update, as described in [Updates for Kubernetes versions and Operating System versions in SKE](https://docs.stackit.cloud/stackit/en/version-updates-in-ske-10125631.html).
     */
    osVersionUsed: string;
    /**
     * Specifies a taint list as defined below.
     */
    taints: outputs.GetSkeClusterNodePoolTaint[];
    /**
     * The volume size in GB.
     */
    volumeSize: number;
    /**
     * Specifies the volume type.
     */
    volumeType: string;
}

export interface GetSkeClusterNodePoolTaint {
    /**
     * The taint effect.
     */
    effect: string;
    /**
     * Taint key to be applied to a node.
     */
    key: string;
    /**
     * Taint value corresponding to the taint key.
     */
    value: string;
}

export interface GetSqlserverflexInstanceFlavor {
    cpu: number;
    description: string;
    id: string;
    ram: number;
}

export interface GetSqlserverflexInstanceOptions {
    edition: string;
    retentionDays: number;
}

export interface GetSqlserverflexInstanceStorage {
    class: string;
    size: number;
}

export interface GetVolumeSource {
    /**
     * The ID of the source, e.g. image ID
     */
    id: string;
    /**
     * The type of the source. Supported values are: `volume`, `image`, `snapshot`, `backup`.
     */
    type: string;
}

export interface ImageChecksum {
    /**
     * Algorithm for the checksum of the image data.
     */
    algorithm: string;
    /**
     * Hexdigest of the checksum of the image data.
     */
    digest: string;
}

export interface ImageConfig {
    /**
     * Enables the BIOS bootmenu.
     */
    bootMenu: boolean;
    /**
     * Sets CDROM bus controller type.
     */
    cdromBus: string;
    /**
     * Sets Disk bus controller type.
     */
    diskBus: string;
    /**
     * Sets virtual network interface model.
     */
    nicModel: string;
    /**
     * Enables operating system specific optimizations.
     */
    operatingSystem: string;
    /**
     * Operating system distribution.
     */
    operatingSystemDistro: string;
    /**
     * Version of the operating system.
     */
    operatingSystemVersion: string;
    /**
     * Sets the device bus when the image is used as a rescue image.
     */
    rescueBus: string;
    /**
     * Sets the device when the image is used as a rescue image.
     */
    rescueDevice: string;
    /**
     * Enables Secure Boot.
     */
    secureBoot: boolean;
    /**
     * Enables UEFI boot.
     */
    uefi: boolean;
    /**
     * Sets Graphic device model.
     */
    videoModel: string;
    /**
     * Enables the use of VirtIO SCSI to provide block device access. By default instances use VirtIO Block.
     */
    virtioScsi: boolean;
}

export interface LoadbalancerListener {
    displayName: string;
    /**
     * Port number where we listen for traffic.
     */
    port: number;
    /**
     * Protocol is the highest network protocol we understand to load balance. Supported values are: `PROTOCOL_UNSPECIFIED`, `PROTOCOL_TCP`, `PROTOCOL_UDP`, `PROTOCOL_TCP_PROXY`, `PROTOCOL_TLS_PASSTHROUGH`.
     */
    protocol: string;
    /**
     * A list of domain names to match in order to pass TLS traffic to the target pool in the current listener
     */
    serverNameIndicators?: outputs.LoadbalancerListenerServerNameIndicator[];
    /**
     * Reference target pool by target pool name.
     */
    targetPool: string;
}

export interface LoadbalancerListenerServerNameIndicator {
    /**
     * A domain name to match in order to pass TLS traffic to the target pool in the current listener
     */
    name?: string;
}

export interface LoadbalancerNetwork {
    /**
     * Openstack network ID.
     */
    networkId: string;
    /**
     * The role defines how the load balancer is using the network. Supported values are: `ROLE_UNSPECIFIED`, `ROLE_LISTENERS_AND_TARGETS`, `ROLE_LISTENERS`, `ROLE_TARGETS`.
     */
    role: string;
}

export interface LoadbalancerOptions {
    /**
     * Load Balancer is accessible only from an IP address in this range.
     */
    acls: string[];
    /**
     * We offer Load Balancer metrics observability via ARGUS or external solutions. Not changeable after creation.
     */
    observability: outputs.LoadbalancerOptionsObservability;
    /**
     * If true, Load Balancer is accessible only via a private network IP address.
     */
    privateNetworkOnly: boolean;
}

export interface LoadbalancerOptionsObservability {
    /**
     * Observability logs configuration. Not changeable after creation.
     */
    logs: outputs.LoadbalancerOptionsObservabilityLogs;
    /**
     * Observability metrics configuration. Not changeable after creation.
     */
    metrics: outputs.LoadbalancerOptionsObservabilityMetrics;
}

export interface LoadbalancerOptionsObservabilityLogs {
    /**
     * Credentials reference for logs. Not changeable after creation.
     */
    credentialsRef: string;
    /**
     * Credentials reference for logs. Not changeable after creation.
     */
    pushUrl: string;
}

export interface LoadbalancerOptionsObservabilityMetrics {
    /**
     * Credentials reference for metrics. Not changeable after creation.
     */
    credentialsRef: string;
    /**
     * Credentials reference for metrics. Not changeable after creation.
     */
    pushUrl: string;
}

export interface LoadbalancerTargetPool {
    activeHealthCheck: outputs.LoadbalancerTargetPoolActiveHealthCheck;
    /**
     * Target pool name.
     */
    name: string;
    /**
     * Here you can setup various session persistence options, so far only "`useSourceIpAddress`" is supported.
     */
    sessionPersistence?: outputs.LoadbalancerTargetPoolSessionPersistence;
    /**
     * Identical port number where each target listens for traffic.
     */
    targetPort: number;
    /**
     * List of all targets which will be used in the pool. Limited to 1000.
     */
    targets: outputs.LoadbalancerTargetPoolTarget[];
}

export interface LoadbalancerTargetPoolActiveHealthCheck {
    /**
     * Healthy threshold of the health checking.
     */
    healthyThreshold: number;
    /**
     * Interval duration of health checking in seconds.
     */
    interval: string;
    /**
     * Interval duration threshold of the health checking in seconds.
     */
    intervalJitter: string;
    /**
     * Active health checking timeout duration in seconds.
     */
    timeout: string;
    /**
     * Unhealthy threshold of the health checking.
     */
    unhealthyThreshold: number;
}

export interface LoadbalancerTargetPoolSessionPersistence {
    /**
     * If true then all connections from one source IP address are redirected to the same target. This setting changes the load balancing algorithm to Maglev.
     */
    useSourceIpAddress?: boolean;
}

export interface LoadbalancerTargetPoolTarget {
    /**
     * Target display name
     */
    displayName: string;
    /**
     * Target IP
     */
    ip: string;
}

export interface LogmeInstanceParameters {
    /**
     * Enable monitoring.
     */
    enableMonitoring: boolean;
    fluentdTcp: number;
    fluentdTls: number;
    fluentdTlsCiphers: string;
    fluentdTlsMaxVersion: string;
    fluentdTlsMinVersion: string;
    fluentdTlsVersion: string;
    fluentdUdp: number;
    /**
     * If set, monitoring with Graphite will be enabled. Expects the host and port where the Graphite metrics should be sent to (host:port).
     */
    graphite: string;
    /**
     * Combination of an integer and a timerange when an index will be considered "old" and can be deleted. Possible values for the timerange are `s`, `m`, `h` and `d`.
     */
    ismDeletionAfter: string;
    ismJitter: number;
    /**
     * Jitter of the execution time.
     */
    ismJobInterval: number;
    /**
     * The amount of memory (in MB) allocated as heap by the JVM for OpenSearch.
     */
    javaHeapspace: number;
    /**
     * The amount of memory (in MB) used by the JVM to store metadata for OpenSearch.
     */
    javaMaxmetaspace: number;
    /**
     * The maximum disk threshold in MB. If the disk usage exceeds this threshold, the instance will be stopped.
     */
    maxDiskThreshold: number;
    /**
     * The frequency in seconds at which metrics are emitted (in seconds).
     */
    metricsFrequency: number;
    /**
     * The prefix for the metrics. Could be useful when using Graphite monitoring to prefix the metrics with a certain value, like an API key.
     */
    metricsPrefix: string;
    /**
     * The ID of the STACKIT monitoring instance.
     */
    monitoringInstanceId: string;
    opensearchTlsCiphers: string[];
    opensearchTlsProtocols: string[];
    /**
     * Comma separated list of IP networks in CIDR notation which are allowed to access this instance.
     */
    sgwAcl: string;
    /**
     * List of syslog servers to send logs to.
     */
    syslogs: string[];
}

export interface MariadbInstanceParameters {
    /**
     * Enable monitoring.
     */
    enableMonitoring: boolean;
    /**
     * Graphite server URL (host and port). If set, monitoring with Graphite will be enabled.
     */
    graphite: string;
    /**
     * The maximum disk threshold in MB. If the disk usage exceeds this threshold, the instance will be stopped.
     */
    maxDiskThreshold: number;
    /**
     * The frequency in seconds at which metrics are emitted.
     */
    metricsFrequency: number;
    /**
     * The prefix for the metrics. Could be useful when using Graphite monitoring to prefix the metrics with a certain value, like an API key
     */
    metricsPrefix: string;
    /**
     * The ID of the STACKIT monitoring instance. Monitoring instances with the plan "Observability-Monitoring-Starter" are not supported.
     */
    monitoringInstanceId: string;
    /**
     * Comma separated list of IP networks in CIDR notation which are allowed to access this instance.
     */
    sgwAcl: string;
    /**
     * List of syslog servers to send logs to.
     */
    syslogs: string[];
}

export interface MongodbflexInstanceFlavor {
    cpu: number;
    description: string;
    id: string;
    ram: number;
}

export interface MongodbflexInstanceOptions {
    /**
     * The number of days that daily backups will be retained.
     */
    dailySnapshotRetentionDays: number;
    /**
     * The number of months that monthly backups will be retained.
     */
    monthlySnapshotRetentionMonths: number;
    /**
     * The number of hours back in time the point-in-time recovery feature will be able to recover.
     */
    pointInTimeWindowHours: number;
    /**
     * The number of days that continuous backups (controlled via the `backupSchedule`) will be retained.
     */
    snapshotRetentionDays: number;
    /**
     * Type of the MongoDB Flex instance. Supported values are: `Replica`, `Sharded`, `Single`.
     */
    type: string;
    /**
     * The number of weeks that weekly backups will be retained.
     */
    weeklySnapshotRetentionWeeks: number;
}

export interface MongodbflexInstanceStorage {
    class: string;
    size: number;
}

export interface NetworkAreaNetworkRange {
    networkRangeId: string;
    /**
     * Classless Inter-Domain Routing (CIDR).
     */
    prefix: string;
}

export interface ObservabilityAlertgroupRule {
    /**
     * The name of the alert rule. Is the identifier and must be unique in the group.
     */
    alert: string;
    /**
     * A map of key:value. Annotations to add or overwrite for each alert
     */
    annotations?: {[key: string]: string};
    /**
     * The PromQL expression to evaluate. Every evaluation cycle this is evaluated at the current time, and all resultant time series become pending/firing alerts.
     */
    expression: string;
    /**
     * Alerts are considered firing once they have been returned for this long. Alerts which have not yet fired for long enough are considered pending. Default is 0s
     */
    for?: string;
    /**
     * A map of key:value. Labels to add or overwrite for each alert
     */
    labels?: {[key: string]: string};
}

export interface ObservabilityInstanceAlertConfig {
    /**
     * Global configuration for the alerts.
     */
    global: outputs.ObservabilityInstanceAlertConfigGlobal;
    /**
     * List of alert receivers.
     */
    receivers: outputs.ObservabilityInstanceAlertConfigReceiver[];
    /**
     * Route configuration for the alerts.
     */
    route: outputs.ObservabilityInstanceAlertConfigRoute;
}

export interface ObservabilityInstanceAlertConfigGlobal {
    /**
     * The API key for OpsGenie.
     */
    opsgenieApiKey?: string;
    /**
     * The host to send OpsGenie API requests to. Must be a valid URL
     */
    opsgenieApiUrl?: string;
    /**
     * The default value used by alertmanager if the alert does not include EndsAt. After this time passes, it can declare the alert as resolved if it has not been updated. This has no impact on alerts from Prometheus, as they always include EndsAt.
     */
    resolveTimeout: string;
    /**
     * SMTP authentication information. Must be a valid email address
     */
    smtpAuthIdentity?: string;
    /**
     * SMTP Auth using LOGIN and PLAIN.
     */
    smtpAuthPassword?: string;
    /**
     * SMTP Auth using CRAM-MD5, LOGIN and PLAIN. If empty, Alertmanager doesn't authenticate to the SMTP server.
     */
    smtpAuthUsername?: string;
    /**
     * The default SMTP From header field. Must be a valid email address
     */
    smtpFrom: string;
    /**
     * The default SMTP smarthost used for sending emails, including port number in format `host:port` (eg. `smtp.example.com:587`). Port number usually is 25, or 587 for SMTP over TLS (sometimes referred to as STARTTLS).
     */
    smtpSmartHost?: string;
}

export interface ObservabilityInstanceAlertConfigReceiver {
    /**
     * List of email configurations.
     */
    emailConfigs?: outputs.ObservabilityInstanceAlertConfigReceiverEmailConfig[];
    /**
     * Name of the receiver.
     */
    name: string;
    /**
     * List of OpsGenie configurations.
     */
    opsgenieConfigs?: outputs.ObservabilityInstanceAlertConfigReceiverOpsgenieConfig[];
    /**
     * List of Webhooks configurations.
     */
    webhooksConfigs?: outputs.ObservabilityInstanceAlertConfigReceiverWebhooksConfig[];
}

export interface ObservabilityInstanceAlertConfigReceiverEmailConfig {
    /**
     * SMTP authentication information. Must be a valid email address
     */
    authIdentity?: string;
    /**
     * SMTP authentication password.
     */
    authPassword?: string;
    /**
     * SMTP authentication username.
     */
    authUsername?: string;
    /**
     * The sender email address. Must be a valid email address
     */
    from?: string;
    /**
     * The SMTP host through which emails are sent.
     */
    smartHost?: string;
    /**
     * The email address to send notifications to. Must be a valid email address
     */
    to?: string;
}

export interface ObservabilityInstanceAlertConfigReceiverOpsgenieConfig {
    /**
     * The API key for OpsGenie.
     */
    apiKey?: string;
    /**
     * The host to send OpsGenie API requests to. Must be a valid URL
     */
    apiUrl?: string;
    /**
     * Comma separated list of tags attached to the notifications.
     */
    tags?: string;
}

export interface ObservabilityInstanceAlertConfigReceiverWebhooksConfig {
    /**
     * Microsoft Teams webhooks require special handling, set this to true if the webhook is for Microsoft Teams.
     */
    msTeams?: boolean;
    /**
     * The endpoint to send HTTP POST requests to. Must be a valid URL
     */
    url?: string;
}

export interface ObservabilityInstanceAlertConfigRoute {
    /**
     * The labels by which incoming alerts are grouped together. For example, multiple alerts coming in for cluster=A and alertname=LatencyHigh would be batched into a single group. To aggregate by all possible labels use the special value '...' as the sole label name, for example: group_by: ['...']. This effectively disables aggregation entirely, passing through all alerts as-is. This is unlikely to be what you want, unless you have a very low alert volume or your upstream notification system performs its own grouping.
     */
    groupBies?: string[];
    /**
     * How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.)
     */
    groupInterval: string;
    /**
     * How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group. (Usually ~0s to few minutes.)
     */
    groupWait: string;
    /**
     * A set of equality matchers an alert has to fulfill to match the node.
     */
    match?: {[key: string]: string};
    /**
     * A set of regex-matchers an alert has to fulfill to match the node.
     */
    matchRegex?: {[key: string]: string};
    /**
     * The name of the receiver to route the alerts to.
     */
    receiver: string;
    /**
     * How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more).
     */
    repeatInterval: string;
    /**
     * List of child routes.
     */
    routes?: outputs.ObservabilityInstanceAlertConfigRouteRoute[];
}

export interface ObservabilityInstanceAlertConfigRouteRoute {
    /**
     * The labels by which incoming alerts are grouped together. For example, multiple alerts coming in for cluster=A and alertname=LatencyHigh would be batched into a single group. To aggregate by all possible labels use the special value '...' as the sole label name, for example: group_by: ['...']. This effectively disables aggregation entirely, passing through all alerts as-is. This is unlikely to be what you want, unless you have a very low alert volume or your upstream notification system performs its own grouping.
     */
    groupBies?: string[];
    /**
     * How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.)
     */
    groupInterval: string;
    /**
     * How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group. (Usually ~0s to few minutes.)
     */
    groupWait: string;
    /**
     * A set of equality matchers an alert has to fulfill to match the node.
     */
    match?: {[key: string]: string};
    /**
     * A set of regex-matchers an alert has to fulfill to match the node.
     */
    matchRegex?: {[key: string]: string};
    /**
     * The name of the receiver to route the alerts to.
     */
    receiver: string;
    /**
     * How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more).
     */
    repeatInterval: string;
}

export interface ObservabilityLogalertgroupRule {
    /**
     * The name of the alert rule. Is the identifier and must be unique in the group.
     */
    alert: string;
    /**
     * A map of key:value. Annotations to add or overwrite for each alert
     */
    annotations?: {[key: string]: string};
    /**
     * The LogQL expression to evaluate. Every evaluation cycle this is evaluated at the current time, and all resultant time series become pending/firing alerts.
     */
    expression: string;
    /**
     * Alerts are considered firing once they have been returned for this long. Alerts which have not yet fired for long enough are considered pending. Default is 0s
     */
    for?: string;
    /**
     * A map of key:value. Labels to add or overwrite for each alert
     */
    labels?: {[key: string]: string};
}

export interface ObservabilityScrapeconfigBasicAuth {
    /**
     * Specifies basic auth password.
     */
    password: string;
    /**
     * Specifies basic auth username.
     */
    username: string;
}

export interface ObservabilityScrapeconfigSaml2 {
    /**
     * Specifies if URL parameters are enabled. Defaults to `true`
     */
    enableUrlParameters: boolean;
}

export interface ObservabilityScrapeconfigTarget {
    /**
     * Specifies labels.
     */
    labels?: {[key: string]: string};
    /**
     * Specifies target URLs.
     */
    urls: string[];
}

export interface OpensearchInstanceParameters {
    /**
     * Enable monitoring.
     */
    enableMonitoring: boolean;
    /**
     * If set, monitoring with Graphite will be enabled. Expects the host and port where the Graphite metrics should be sent to (host:port).
     */
    graphite: string;
    /**
     * The garbage collector to use for OpenSearch.
     */
    javaGarbageCollector: string;
    /**
     * The amount of memory (in MB) allocated as heap by the JVM for OpenSearch.
     */
    javaHeapspace: number;
    /**
     * The amount of memory (in MB) used by the JVM to store metadata for OpenSearch.
     */
    javaMaxmetaspace: number;
    /**
     * The maximum disk threshold in MB. If the disk usage exceeds this threshold, the instance will be stopped.
     */
    maxDiskThreshold: number;
    /**
     * The frequency in seconds at which metrics are emitted (in seconds).
     */
    metricsFrequency: number;
    /**
     * The prefix for the metrics. Could be useful when using Graphite monitoring to prefix the metrics with a certain value, like an API key.
     */
    metricsPrefix: string;
    /**
     * The ID of the STACKIT monitoring instance.
     */
    monitoringInstanceId: string;
    /**
     * List of plugins to install. Must be a supported plugin name. The plugins `repository-s3` and `repository-azure` are enabled by default and cannot be disabled.
     */
    plugins: string[];
    /**
     * Comma separated list of IP networks in CIDR notation which are allowed to access this instance.
     */
    sgwAcl: string;
    /**
     * List of syslog servers to send logs to.
     */
    syslogs: string[];
    /**
     * List of TLS ciphers to use.
     */
    tlsCiphers: string[];
    /**
     * The TLS protocol to use.
     */
    tlsProtocols: string;
}

export interface PostgresflexInstanceFlavor {
    cpu: number;
    description: string;
    id: string;
    ram: number;
}

export interface PostgresflexInstanceStorage {
    class: string;
    size: number;
}

export interface RabbitmqInstanceParameters {
    /**
     * The timeout in milliseconds for the consumer.
     */
    consumerTimeout: number;
    /**
     * Enable monitoring.
     */
    enableMonitoring: boolean;
    /**
     * Graphite server URL (host and port). If set, monitoring with Graphite will be enabled.
     */
    graphite: string;
    /**
     * The maximum disk threshold in MB. If the disk usage exceeds this threshold, the instance will be stopped.
     */
    maxDiskThreshold: number;
    /**
     * The frequency in seconds at which metrics are emitted.
     */
    metricsFrequency: number;
    /**
     * The prefix for the metrics. Could be useful when using Graphite monitoring to prefix the metrics with a certain value, like an API key
     */
    metricsPrefix: string;
    /**
     * The ID of the STACKIT monitoring instance.
     */
    monitoringInstanceId: string;
    /**
     * List of plugins to install. Must be a supported plugin name.
     */
    plugins: string[];
    /**
     * List of roles to assign to the instance.
     */
    roles: string[];
    /**
     * Comma separated list of IP networks in CIDR notation which are allowed to access this instance.
     */
    sgwAcl: string;
    /**
     * List of syslog servers to send logs to.
     */
    syslogs: string[];
    /**
     * List of TLS ciphers to use.
     */
    tlsCiphers: string[];
    /**
     * TLS protocol to use.
     */
    tlsProtocols: string;
}

export interface RedisInstanceParameters {
    /**
     * The number of milliseconds after which the instance is considered down.
     */
    downAfterMilliseconds: number;
    /**
     * Enable monitoring.
     */
    enableMonitoring: boolean;
    /**
     * The failover timeout in milliseconds.
     */
    failoverTimeout: number;
    /**
     * Graphite server URL (host and port). If set, monitoring with Graphite will be enabled.
     */
    graphite: string;
    /**
     * The lazy eviction enablement (yes or no).
     */
    lazyfreeLazyEviction: string;
    /**
     * The lazy expire enablement (yes or no).
     */
    lazyfreeLazyExpire: string;
    /**
     * The Lua time limit.
     */
    luaTimeLimit: number;
    /**
     * The maximum disk threshold in MB. If the disk usage exceeds this threshold, the instance will be stopped.
     */
    maxDiskThreshold: number;
    /**
     * The maximum number of clients.
     */
    maxclients: number;
    /**
     * The policy to handle the maximum memory (volatile-lru, noeviction, etc).
     */
    maxmemoryPolicy: string;
    /**
     * The maximum memory samples.
     */
    maxmemorySamples: number;
    /**
     * The frequency in seconds at which metrics are emitted.
     */
    metricsFrequency: number;
    /**
     * The prefix for the metrics. Could be useful when using Graphite monitoring to prefix the metrics with a certain value, like an API key
     */
    metricsPrefix: string;
    /**
     * The minimum replicas maximum lag.
     */
    minReplicasMaxLag: number;
    /**
     * The ID of the STACKIT monitoring instance.
     */
    monitoringInstanceId: string;
    /**
     * The notify keyspace events.
     */
    notifyKeyspaceEvents: string;
    /**
     * Comma separated list of IP networks in CIDR notation which are allowed to access this instance.
     */
    sgwAcl: string;
    /**
     * The snapshot configuration.
     */
    snapshot: string;
    /**
     * List of syslog servers to send logs to.
     */
    syslogs: string[];
    /**
     * List of TLS ciphers to use.
     */
    tlsCiphers: string[];
    /**
     * TLS cipher suites to use.
     */
    tlsCiphersuites: string;
    /**
     * TLS protocol to use.
     */
    tlsProtocols: string;
}

export interface SecurityGroupRuleIcmpParameters {
    /**
     * ICMP code. Can be set if the protocol is ICMP.
     */
    code: number;
    /**
     * ICMP type. Can be set if the protocol is ICMP.
     */
    type: number;
}

export interface SecurityGroupRulePortRange {
    /**
     * The maximum port number. Should be greater or equal to the minimum.
     */
    max: number;
    /**
     * The minimum port number. Should be less or equal to the maximum.
     */
    min: number;
}

export interface SecurityGroupRuleProtocol {
    /**
     * The protocol name which the rule should match. Either `name` or `number` must be provided. Possible values are: `ah`, `dccp`, `egp`, `esp`, `gre`, `icmp`, `igmp`, `ipip`, `ipv6-encap`, `ipv6-frag`, `ipv6-icmp`, `ipv6-nonxt`, `ipv6-opts`, `ipv6-route`, `ospf`, `pgm`, `rsvp`, `sctp`, `tcp`, `udp`, `udplite`, `vrrp`.
     */
    name: string;
    /**
     * The protocol number which the rule should match. Either `name` or `number` must be provided.
     */
    number: number;
}

export interface ServerBackupScheduleBackupProperties {
    name: string;
    retentionPeriod: number;
    volumeIds?: string[];
}

export interface ServerBootVolume {
    /**
     * Delete the volume during the termination of the server. Only allowed when `sourceType` is `image`.
     */
    deleteOnTermination: boolean;
    /**
     * The ID of the boot volume
     */
    id: string;
    /**
     * The performance class of the server.
     */
    performanceClass?: string;
    /**
     * The size of the boot volume in GB. Must be provided when `sourceType` is `image`.
     */
    size?: number;
    /**
     * The ID of the source, either image ID or volume ID
     */
    sourceId: string;
    /**
     * The type of the source. Supported values are: `volume`, `image`.
     */
    sourceType: string;
}

export interface SkeClusterExtensions {
    /**
     * Cluster access control configuration.
     */
    acl?: outputs.SkeClusterExtensionsAcl;
    /**
     * A single argus block as defined below.
     */
    argus?: outputs.SkeClusterExtensionsArgus;
    /**
     * DNS extension configuration
     */
    dns?: outputs.SkeClusterExtensionsDns;
}

export interface SkeClusterExtensionsAcl {
    /**
     * Specify a list of CIDRs to whitelist.
     */
    allowedCidrs: string[];
    /**
     * Is ACL enabled?
     */
    enabled: boolean;
}

export interface SkeClusterExtensionsArgus {
    /**
     * Argus instance ID to choose which Argus instance is used. Required when enabled is set to `true`.
     */
    argusInstanceId?: string;
    /**
     * Flag to enable/disable Argus extensions.
     */
    enabled: boolean;
}

export interface SkeClusterExtensionsDns {
    /**
     * Flag to enable/disable DNS extensions
     */
    enabled: boolean;
    /**
     * Specify a list of domain filters for externalDNS (e.g., `foo.runs.onstackit.cloud`)
     */
    zones: string[];
}

export interface SkeClusterHibernation {
    /**
     * End time of hibernation in crontab syntax. E.g. `0 8 * * *` for waking up the cluster at 8am.
     */
    end: string;
    /**
     * Start time of cluster hibernation in crontab syntax. E.g. `0 18 * * *` for starting everyday at 6pm.
     */
    start: string;
    /**
     * Timezone name corresponding to a file in the IANA Time Zone database. i.e. `Europe/Berlin`.
     */
    timezone: string;
}

export interface SkeClusterMaintenance {
    /**
     * Flag to enable/disable auto-updates of the Kubernetes version. Defaults to `true`. SKE automatically updates the cluster Kubernetes version if you have set `maintenance.enable_kubernetes_version_updates` to true or if there is a mandatory update, as described in [Updates for Kubernetes versions and Operating System versions in SKE](https://docs.stackit.cloud/stackit/en/version-updates-in-ske-10125631.html).
     */
    enableKubernetesVersionUpdates: boolean;
    /**
     * Flag to enable/disable auto-updates of the OS image version. Defaults to `true`. SKE automatically updates the cluster Kubernetes version if you have set `maintenance.enable_kubernetes_version_updates` to true or if there is a mandatory update, as described in [Updates for Kubernetes versions and Operating System versions in SKE](https://docs.stackit.cloud/stackit/en/version-updates-in-ske-10125631.html).
     */
    enableMachineImageVersionUpdates: boolean;
    /**
     * Time for maintenance window end. E.g. `01:23:45Z`, `05:00:00+02:00`.
     */
    end: string;
    /**
     * Time for maintenance window start. E.g. `01:23:45Z`, `05:00:00+02:00`.
     */
    start: string;
}

export interface SkeClusterNetwork {
    /**
     * ID of the STACKIT Network Area (SNA) network into which the cluster will be deployed.
     */
    id?: string;
}

export interface SkeClusterNodePool {
    /**
     * Allow system components to run on this node pool.
     */
    allowSystemComponents: boolean;
    /**
     * Specify a list of availability zones. E.g. `eu01-m`
     */
    availabilityZones: string[];
    /**
     * Specifies the container runtime. Defaults to `containerd`
     */
    cri: string;
    /**
     * Labels to add to each node.
     */
    labels: {[key: string]: string};
    /**
     * The machine type.
     */
    machineType: string;
    /**
     * Maximum number of additional VMs that are created during an update. If set (larger than 0), then it must be at least the amount of zones configured for the nodepool. The `maxSurge` and `maxUnavailable` fields cannot both be unset at the same time.
     */
    maxSurge: number;
    /**
     * Maximum number of VMs that that can be unavailable during an update. If set (larger than 0), then it must be at least the amount of zones configured for the nodepool. The `maxSurge` and `maxUnavailable` fields cannot both be unset at the same time.
     */
    maxUnavailable: number;
    /**
     * Maximum number of nodes in the pool.
     */
    maximum: number;
    /**
     * Minimum number of nodes in the pool.
     */
    minimum: number;
    /**
     * Specifies the name of the node pool.
     */
    name: string;
    /**
     * The name of the OS image. Defaults to `flatcar`.
     */
    osName: string;
    /**
     * This field is deprecated, use `osVersionMin` to configure the version and `osVersionUsed` to get the currently used version instead.
     *
     * @deprecated Use `osVersionMin` to configure the version and `osVersionUsed` to get the currently used version instead. Setting a specific OS image version will cause errors during minor OS upgrades due to forced updates.
     */
    osVersion?: string;
    /**
     * The minimum OS image version. This field will be used to set the minimum OS image version on creation/update of the cluster. If unset, the latest supported OS image version will be used. SKE automatically updates the cluster Kubernetes version if you have set `maintenance.enable_kubernetes_version_updates` to true or if there is a mandatory update, as described in [Updates for Kubernetes versions and Operating System versions in SKE](https://docs.stackit.cloud/stackit/en/version-updates-in-ske-10125631.html). To get the current OS image version being used for the node pool, use the read-only `osVersionUsed` field.
     */
    osVersionMin?: string;
    /**
     * Full OS image version used. For example, if 3815.2 was set in `osVersionMin`, this value may result to 3815.2.2. SKE automatically updates the cluster Kubernetes version if you have set `maintenance.enable_kubernetes_version_updates` to true or if there is a mandatory update, as described in [Updates for Kubernetes versions and Operating System versions in SKE](https://docs.stackit.cloud/stackit/en/version-updates-in-ske-10125631.html).
     */
    osVersionUsed: string;
    /**
     * Specifies a taint list as defined below.
     */
    taints?: outputs.SkeClusterNodePoolTaint[];
    /**
     * The volume size in GB. Defaults to `20`
     */
    volumeSize: number;
    /**
     * Specifies the volume type. Defaults to `storagePremiumPerf1`.
     */
    volumeType: string;
}

export interface SkeClusterNodePoolTaint {
    /**
     * The taint effect. E.g `PreferNoSchedule`.
     */
    effect: string;
    /**
     * Taint key to be applied to a node.
     */
    key: string;
    /**
     * Taint value corresponding to the taint key.
     */
    value: string;
}

export interface SqlserverflexInstanceFlavor {
    cpu: number;
    description: string;
    id: string;
    ram: number;
}

export interface SqlserverflexInstanceOptions {
    edition: string;
    retentionDays: number;
}

export interface SqlserverflexInstanceStorage {
    class: string;
    size: number;
}

export interface VolumeSource {
    /**
     * The ID of the source, e.g. image ID
     */
    id: string;
    /**
     * The type of the source. Supported values are: `volume`, `image`, `snapshot`, `backup`.
     */
    type: string;
}

